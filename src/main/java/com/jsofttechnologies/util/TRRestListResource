package dk.topdanmark.tr.common;

import org.apache.taglibs.standard.tag.common.core.Util;
import portalprotect.org.json.JSONArray;
import portalprotect.org.json.JSONException;
import portalprotect.org.json.JSONObject;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.Encoded;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class TRRestListResource<T> {


    @Context
    private HttpServletRequest httpServletRequest;
    @PersistenceContext(unitName = "claim")
    private EntityManager entityManager;
    private Class<T> classType;


    public TRRestListResource(Class<T> classType) {
        this.classType = classType;
    }

    public Response getResult() {
        Response response = null;
        TRRestList<T> restList = new TRRestList<T>();
        Map<String, Object> queryParam = getQueryParam();
        restList.setEntityManager(entityManager).setJpaName("claim").setJpaClass(classType).setMaxResults(25);

        if (queryParam.containsKey("start")) {
            restList.setFirstResult(Integer.valueOf(queryParam.get("start").toString()));
        }

        if (queryParam.containsKey("max")) {
            restList.setMaxResults(Integer.valueOf(queryParam.get("max").toString()));
        }

        if (queryParam.containsKey("orderby")) {
            if (queryParam.get("orderby") instanceof String[]) {
                restList.setSorts((String[]) queryParam.get("orderby"));
            } else {
                String[] orders = new String[1];
                orders[0] = queryParam.get("orderby").toString();
                restList.setSorts(orders);
            }
        }

        if (queryParam.containsKey("q")) {
            restList.setQuery(queryParam.get("q").toString());
        }

        if (queryParam.containsKey("fields")) {
            List<String> fieldList = (List<String>) queryParam.get("fields");
            restList.setFields(fieldList.toArray(new String[fieldList.size()]));
        }

        List<T> resultList = restList.getResultList();

        response = Response.ok(resultList).type(MediaType.APPLICATION_JSON_TYPE)
                .header("x-start", restList.getFirstResult())
                .header("x-max", restList.getMaxResults())
                .header("x-data-resultCount", resultList.size())
                .header("x-data-totalCount", restList.getTotalCount())
                .header("x-query", restList.getQuery())
                .build();

        return response;
    }

    private Map<String, Object> getQueryParam() {
        Map<String, Object> mappedQuery = new HashMap<String, Object>();
        String queryString = null;

        queryString = httpServletRequest.getQueryString();

        if (queryString != null) {
            queryString = queryString.replaceAll("%20", "");
            String[] mappedStrings = queryString.split("&");
            for (String mappedString : mappedStrings) {
                String[] queryParam = mappedString.split("=");
                String field = queryParam[0];
                String value = queryParam[1];
                if (field.equalsIgnoreCase("start") || field.equalsIgnoreCase("max")
                        || field.equalsIgnoreCase("q") || field.equalsIgnoreCase("orderby")) {
                    if (value.contains(",")) {
                        mappedQuery.put(field.toLowerCase(), value.split(","));
                    } else {
                        mappedQuery.put(field.toLowerCase(), value);
                    }
                } else {
                    if (mappedQuery.containsKey("fields")) {
                        ((List<String>) mappedQuery.get("fields")).add(mappedString);
                    } else {
                        List<String> fieldList = new ArrayList<String>();
                        fieldList.add(mappedString);
                        mappedQuery.put("fields", fieldList);
                    }
                }
            }
        }
        return mappedQuery;
    }


}
